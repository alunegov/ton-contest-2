
int preload_grams(slice s) asm "LDGRAMS" "DROP";

;; returns round, old_round, comsa, seqno, owner
_ load_data() {
    slice ds = get_data().begin_parse();
    var res = (ds~load_dict(), ds~load_dict(), ds~load_grams(), ds~load_uint(32), ds~load_uint(256));
    ds.end_parse();
    return res;
}

() save_data(cell round, cell old_round, int comsa, int seqno, int owner) impure {
    set_data(begin_cell()
        .store_dict(round)
        .store_dict(old_round)
        .store_grams(comsa)
        .store_uint(seqno, 32)
        .store_uint(owner, 256)
        .end_cell());    
}

;; returns prize_fund, participants
_ unpack_round(cell round) {
    if (round.null?()) {
        return (0, new_dict());
    }
    slice ds = round.begin_parse();
    var res = (ds~load_grams(), ds~load_dict());
    ds.end_parse();
    return res;
}

cell pack_round(int prize_fund, cell participants) {
    return begin_cell()
        .store_grams(prize_fund)
        .store_dict(participants)
        .end_cell();
}

;; returns lucky_nums, prize1, prize2, prize3, winners
_ unpack_old_round(cell old_round) {
    slice ds = old_round.begin_parse();
    var res = (ds~load_dict(), ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    ds.end_parse();
    return res;
}

cell pack_old_round(cell lucky_nums, int prize1, int prize2, int prize3, cell winners) {
    return begin_cell()
        .store_dict(lucky_nums)
        .store_grams(prize1)
        .store_grams(prize2)
        .store_grams(prize3)
        .store_dict(winners)
        .end_cell();
}

() send_message_back(slice addr, int ans_tag, int query_id, int body, int grams, int mode) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  builder msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(ans_tag, 32)
    .store_uint(query_id, 64);
  if (body >= 0) {
    msg~store_uint(body, 32);
  }
  send_raw_message(msg.end_cell(), mode);
}

;; register participant in current round ("sell" ticket)
() buy_ticket(slice s_addr, int msg_value, slice in_msg, int query_id) impure {
    ;;in_msg~dump();

    ;; ticket price is GR$1
    if (msg_value < 1000000000) {
        ;; not enough money to buy a ticket - return money
        return send_message_back(s_addr, 0x80000001, query_id, 1, 0, 64);
    }

    (int wc, int addr) = parse_std_addr(s_addr);

    var (n1, n2, n3) = (in_msg~load_uint(8), in_msg~load_uint(8), in_msg~load_uint(8));
    in_msg.end_parse();

    if ((n1 == n2) | (n1 == n3) | (n2 == n3)) {
        ;; got non-unique nums - return money
        return send_message_back(s_addr, 0x80000001, query_id, 2, 0, 64);
    }
    if ((n1 >= 100) | (n2 >= 100) | (n3 >= 100)) {
        ;; got out-of-range 0-99 nums - return money
        return send_message_back(s_addr, 0x80000001, query_id, 5, 0, 64);
    }

    var (round, old_round, comsa, seqno, owner) = load_data();

    var (prize_fund, participants) = unpack_round(round);

    (cell wc_participants, int f) = participants.idict_get_ref?(8, wc);
    ifnot (f) {
        wc_participants = new_dict();
    }

    builder nums = begin_cell()
        .store_uint(n1, 8)
        .store_uint(n2, 8)
        .store_uint(n3, 8);

    f = wc_participants~udict_add_builder?(256, addr, nums);
    ifnot (f) {
        ;; addr already bought a ticket - return money (for now one addr - one ticket)
        return send_message_back(s_addr, 0x80000001, query_id, 3, 0, 64);
    }

    participants~idict_set_ref(8, wc, wc_participants);
    
    ;; increase prize fund by ticket price
    ;; TODO: gas?
    round = pack_round(prize_fund + 1000000000, participants);

    save_data(round, old_round, comsa, seqno, owner);

    ;; return change - all above ticket price
    if (msg_value > 1000000000) {
        send_message_back(s_addr, 0x00000014, query_id, 0, msg_value - 1000000000, 2);
    }

    ;; TODO: confirmation?

    return ();
}

;; parses transfer comment for 3 nums (expected input is 3 nums 0-99 separated with space)
;; returns nums, ok
(cell, int) comment_to_nums(slice in_msg) {
    builder nums = begin_cell();

    int comment_len = slice_bits(in_msg) / 8;
    int nums_count = 0;
    var l = nil;
    do {
        int char = 0x20;
        ifnot (in_msg.slice_empty?()) {
            char = in_msg~load_uint(8);
        }
        if (char == 0x20) {
            int num = 0;
            int order = 1;
            do {
                (int n, l) = l.uncons();
                num += (n - 0x30) * order;
                order *= 10;
            } until (l.null?());
            nums~store_uint(num, 8);
            nums_count += 1;
        } else {
            l = cons(char, l);
        }
    } until (nums_count == 3);

    return (nums.end_cell(), true);
}

;; increase prize fund in current round
() sponsor_prize_fund(int msg_value) impure {
    var (round, old_round, comsa, seqno, owner) = load_data();
    
    var (prize_fund, participants) = unpack_round(round);
    
    ;; TODO: gas?
    round = pack_round(prize_fund + msg_value, participants);

    save_data(round, old_round, comsa, seqno, owner);

    ;; TODO: confirmation?

    return ();
}

;; sends prize in prev round to addr
() withdraw_prize(slice s_addr, int query_id) impure {
    (int wc, int addr) = parse_std_addr(s_addr);

    var (round, old_round, comsa, seqno, owner) = load_data();

    if (old_round.null?()) {
        ;; no old_round - return money
        return send_message_back(s_addr, 0xfffffffe, query_id, -1, 0, 64);
    }

    var (lucky_nums, prize1, prize2, prize3, winners) = unpack_old_round(old_round);
    
    (cell wc_winners, int f) = winners.idict_get_ref?(8, wc);
    ifnot (f) {
        ;; not a winner by wc - return money
        return send_message_back(s_addr, 0xfffffffe, query_id, -1, 0, 64);
    }

    (slice matched_nums_s, f) = wc_winners~udict_delete_get?(256, addr);
    ifnot (f) {
        ;; not a winner by addr in wc - return money
        return send_message_back(s_addr, 0xfffffffe, query_id, -1, 0, 64);
    }

    int matched_nums = matched_nums_s~load_uint(2);
    matched_nums_s.end_parse();

    ifnot (wc_winners.dict_empty?()) {
        winners~idict_set_ref(8, wc, wc_winners);
    } else {
        ;; remove empty wc
        winners~idict_delete(8, wc);
    }

    cell old_round = pack_old_round(lucky_nums, prize1, prize2, prize3, winners);

    save_data(round, old_round, comsa, seqno, owner);

    int amount = 0;
    if (matched_nums == 1) {
        amount = prize1;
    }
    if (matched_nums == 2) {
        amount = prize2;
    }
    if (matched_nums == 3) {
        amount = prize3;
    }
    send_message_back(s_addr, 0x80000003, query_id, -1, amount, 64);
}

;; runs lottery round
;; returns round, old_round, round_comsa
(cell, cell, int) conduct_round(cell round, cell old_round) {
    var (prize_fund, participants) = unpack_round(round);

    if (participants.null?()) {
        ;; no participants - prolong round
        return (round, old_round, 0);
    }

    randomize_lt();

    cell lucky_nums = new_dict();
    ;; DEBUG ONLY
    ;;lucky_nums~udict_add_builder?(8, 0, begin_cell());
    ;;lucky_nums~udict_add_builder?(8, 1, begin_cell());
    ;;lucky_nums~udict_add_builder?(8, 2, begin_cell());
    int i = 0;
    while (i < 13) {
        int f = lucky_nums~udict_add_builder?(8, rand(100), begin_cell());
        if (f) {
            i += 1;
       }
    }

    ;; number of winners with 1, 2 and 3 matched nums
    int winners_count1 = 0;
    int winners_count2 = 0;
    int winners_count3 = 0;
    
    ;; dict with winners with wc as key and dict of addrs as value
    cell winners = new_dict();

    (int wc, cell wc_participants, int wc_f) = participants.idict_get_min_ref?(8, wc);
    while (wc_f) {
        ;; dict with winners in wc with addr as key and number of matched nums as value
        cell wc_winners = new_dict();

        int addr = -1;
        do {
            (addr, slice nums, int addr_f) = wc_participants.udict_get_next?(256, addr);
            if (addr_f) {
                nums~touch();
                var (n1, n2, n3) = (nums~load_uint(8), nums~load_uint(8), nums~load_uint(8));
                nums.end_parse();

                int matched_nums = 0;
                (_, int f1) = lucky_nums.udict_get?(8, n1);
                if (f1) {
                    matched_nums += 1;
                }
                (_, f1) = lucky_nums.udict_get?(8, n2);
                if (f1) {
                    matched_nums += 1;
                }
                (_, f1) = lucky_nums.udict_get?(8, n3);
                if (f1) {
                    matched_nums += 1;
                }

                ifnot (matched_nums == 0) {
                    wc_winners~udict_set_builder(256, addr, begin_cell().store_uint(matched_nums, 2));
                }

                if (matched_nums == 1) {
                    winners_count1 += 1;
                }
                if (matched_nums == 2) {
                    winners_count2 += 1;
                }
                if (matched_nums == 3) {
                    winners_count3 += 1;
                }
            }
        } until (~ addr_f);

        ifnot (wc_winners.dict_empty?()) {
            winners~idict_set_builder(8, wc, begin_cell().store_dict(wc_winners));
        }

        (wc, wc_participants, wc_f) = participants.idict_get_next_ref?(8, wc);
    } until (~ wc_f);

    int pf3 = prize_fund * 6 / 10;
    int pf2 = prize_fund * 22 / 100;
    int pf1 = prize_fund * 15 / 100;
    ;; TODO: calc comsa only from current round tickets, excluding prev round fund?
    int comsa = prize_fund * 3 / 100;

    int next_round_fund = prize_fund - comsa;

    ;; prize for each winner with 1, 2 and 3 matched nums
    int prize1 = 0;
    int prize2 = 0;
    int prize3 = 0;
    if (winners_count1 > 0) {
        prize1 = pf1 / winners_count1;
        next_round_fund -= pf1;
    }
    if (winners_count2 > 0) {
        prize2 = pf2 / winners_count2;
        next_round_fund -= pf2;
    }
    if (winners_count3 > 0) {
        prize3 = pf3 / winners_count3;
        next_round_fund -= pf3;
    }

    ;; reset "next current" round
    round = pack_round(next_round_fund, new_dict());

    ;; form result of current round - prev round
    old_round = pack_old_round(lucky_nums, prize1, prize2, prize3, winners);

    return (round, old_round, comsa);
}

;; from any account
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();

    if ((flags & 1) | in_msg.slice_empty?()) {
        ;; a bounced message, or a simple transfer without comment - accept money
        return ();
    }

    int op = in_msg~load_uint(32);

    if (op == 0) {
        ;; simple transfer with comment - buy ticket with nums from comment (str -> 3 nums)
        ;; if except while parsing - will return msg/money
        (cell nums, int ok) = comment_to_nums(in_msg);
        ifnot (ok) {
            ;; comment parse err - just accept money
            return ();
        }
        return buy_ticket(s_addr, msg_value, nums.begin_parse(), 0);
    }

    ;; TODO: query_id: int64

    if (op == 1) {
        ;; buy a ticket
        return buy_ticket(s_addr, msg_value, in_msg, 0);
    }
    
    if (op == 2) {
        ;; increase prize fund
        in_msg.end_parse();
        return sponsor_prize_fund(msg_value);
    }

    if (op == 3) {
        ;; withdraw prize
        in_msg.end_parse();
        return withdraw_prize(s_addr, 0);
    }

    ifnot (op & (1 << 31)) {
        ;; unknown query - return money
        return send_message_back(s_addr, 0xffffffff, 0, op, 0, 64);
    }

    ;; unknown answer, ignore - accept money
    return ();
}

;; from onwer only
;; based on wallet-v2
() recv_external(slice in_msg) impure {
    slice signature = in_msg~load_bits(512);
    slice cs = in_msg;
    var (msg_seqno, valid_until, op) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
    throw_if(35, valid_until <= now());
    var (round, old_round, comsa, seqno, owner) = load_data();
    throw_unless(33, msg_seqno == seqno);
    throw_unless(34, check_signature(slice_hash(in_msg), signature, owner));
    accept_message();
    ;; DEBUG ONLY
    ;;if (op == 1) {
    ;;    ;; transfer
    ;;    cs~touch();
    ;;    while (cs.slice_refs()) {
    ;;        int mode = cs~load_uint(8);
    ;;        send_raw_message(cs~load_ref(), mode);
    ;;    }
    ;;    cs.end_parse();
    ;;}
    if (op == 2) {
        ;; conduct round
        cs.end_parse();
        (round, old_round, int round_comsa) = conduct_round(round, old_round);
        comsa += round_comsa;
    }
    if (op == 3) {
        ;; withdraw commision
        cs~touch();
        slice dest_addr_s = cs~load_bits(8 + 256);
        cs.end_parse();

        ;; send all comsa
        send_message_back(dest_addr_s, 0x00000013, 0, -1, comsa, 2);
        comsa = 0;
    }
    ;; op for init - anything except [1, ]2, 3
    save_data(round, old_round, comsa, seqno + 1, owner);
}

;; Get methods

int seqno() method_id {
    (_, _, _, int seqno, _) = load_data();
    return seqno;
}

;; returns prize fund of current round
int prize_fund() method_id {
    cell round = get_data().begin_parse().preload_dict();
    return round.null?() ? 0 : round.begin_parse().preload_grams();
}

;; returns winning nums of prev round
cell lucky_nums() method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return begin_cell().end_cell();
    }
    cell lucky_nums = old_round.begin_parse().preload_dict();
    ;; convert dict to list
    builder res = begin_cell();
    int i = -1;
    do {
        (i, _, int f) = lucky_nums.udict_get_next?(8, i);
        if (f) {
            res~store_uint(i, 8);
        }
    } until (~ f);
    return res.end_cell();
}

;; returns prizes (1, 2 and 3 nums matched) and winners of prev round
(int, int, int, cell) winners() method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return (0, 0, 0, new_dict());
    }

    slice ds = old_round.begin_parse().skip_dict();
    var (prize1, prize2, prize3, winners) = (ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    ;;ds.end_parse();

    return (prize1, prize2, prize3, winners);
}

;; returns prize in prev round for addr
int is_winner(int wc, int addr) method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return 0;
    }

    slice ds = old_round.begin_parse().skip_dict();
    var (prize1, prize2, prize3, winners) = (ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    ;;ds.end_parse();

    (cell wc_winners, int f) = winners.idict_get_ref?(8, wc);
    ifnot (f) {
        return 0;
    }

    (slice matched_nums_s, f) = wc_winners.udict_get?(256, addr);
    if (f) {
        int matched_nums = matched_nums_s.preload_uint(2);
        if (matched_nums == 1) {
            return prize1;
        }
        if (matched_nums == 2) {
            return prize2;
        }
        if (matched_nums == 3) {
            return prize3;
        }
    }

    return 0;
}

;; returns commision. debug only?
int comsa() method_id {
    return get_data().begin_parse().skip_dict().skip_dict().preload_grams();
}
