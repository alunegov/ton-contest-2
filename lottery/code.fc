
int preload_grams(slice s) asm "LDGRAMS" "DROP";

;; round, old_round, comsa, seqno, owner
_ load_data() {
    slice ds = get_data().begin_parse();
    var res = (ds~load_dict(), ds~load_dict(), ds~load_grams(), ds~load_uint(32), ds~load_uint(256));
    ds.end_parse();
    return res;
}

() save_data(cell round, cell old_round, int comsa, int seqno, int owner) impure {
    set_data(begin_cell()
        .store_dict(round)
        .store_dict(old_round)
        .store_grams(comsa)
        .store_uint(seqno, 32)
        .store_uint(owner, 256)
        .end_cell());    
}

;; prize_fund, participants
_ unpack_round(cell round) {
    if (round.null?()) {
        return (0, new_dict());
    }
    slice ds = round.begin_parse();
    var res = (ds~load_grams(), ds~load_dict());
    ds.end_parse();
    return res;
}

cell pack_round(int prize_fund, cell participants) {
    return begin_cell()
        .store_grams(prize_fund)
        .store_dict(participants)
        .end_cell();
}

;; lucky_nums, p1, p2, p3, d
_ unpack_old_round(cell old_round) {
    slice ds = old_round.begin_parse();
    var res = (ds~load_dict(), ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    ds.end_parse();
    return res;
}

cell pack_old_round(cell lucky_nums, int p1, int p2, int p3, cell d) {
    return begin_cell()
        .store_dict(lucky_nums)
        .store_grams(p1)
        .store_grams(p2)
        .store_grams(p3)
        .store_dict(d)
        .end_cell();
}

() send_message_back(slice addr, int ans_tag, int query_id, int body, int grams, int mode) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  builder msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(ans_tag, 32)
    .store_uint(query_id, 64);
  if (body >= 0) {
    msg~store_uint(body, 32);
  }
  send_raw_message(msg.end_cell(), mode);
}

;; register participant in current round (sell ticket)
() buy_ticket(slice s_addr, int msg_value, slice in_msg, int query_id) impure {
    ;; TODO: return all above GR$1
    ;; ticket price is GR$1
    if (msg_value < 1000000000) {
        ;; not enough money to buy a ticket - return money
        return send_message_back(s_addr, 0x80000001, query_id, 1, 0, 64);
    }

    (int wc, int addr) = parse_std_addr(s_addr);
    ;;throw_unless(39, wc == 0);
    ;; TODO: wc?

    var (n1, n2, n3) = (in_msg~load_uint(8), in_msg~load_uint(8), in_msg~load_uint(8));
    in_msg.end_parse();

    if ((n1 == n2) | (n1 == n3) | (n2 == n3)) {
        ;; got non-unique nums - return money
        return send_message_back(s_addr, 0x80000001, query_id, 2, 0, 64);
    }

    var (round, old_round, comsa, seqno, owner) = load_data();

    var (prize_fund, participants) = unpack_round(round);

    builder nums = begin_cell()
        .store_uint(n1, 8)
        .store_uint(n2, 8)
        .store_uint(n3, 8);

    var f = participants~udict_add_builder?(256, addr, nums);
    ifnot (f) {
        ;; addr already bought a ticket - return money (for now one addr - one ticket)
        return send_message_back(s_addr, 0x80000001, query_id, 3, 0, 64);
    }
    
    ;; TODO: increase prize fund by GR$1
    ;; TODO: gas?
    round = pack_round(prize_fund + msg_value, participants);

    save_data(round, old_round, comsa, seqno, owner);

    ;; TODO: confirmation?

    return ();
}

;; increase prize fund in current round
() sponsor_prize_fund(int msg_value) impure {
    var (round, old_round, comsa, seqno, owner) = load_data();
    
    var (prize_fund, participants) = unpack_round(round);
    
    ;; TODO: gas?
    round = pack_round(prize_fund + msg_value, participants);

    save_data(round, old_round, comsa, seqno, owner);

    ;; TODO: confirmation?

    return ();
}

;; sends prize in prev round to addr
() withdraw_prize(slice s_addr, int query_id) impure {
    (int wc, int addr) = parse_std_addr(s_addr);
    ;;throw_unless(39, wc == 0);
    ;; TODO: wc?

    var (round, old_round, comsa, seqno, owner) = load_data();

    if (old_round.null?()) {
        return send_message_back(s_addr, 0xfffffffe, query_id, -1, 0, 64);
    }

    var (lucky_nums, p1, p2, p3, d) = unpack_old_round(old_round);
    
    var (ms, f) = d~udict_delete_get?(256, addr);
    ifnot (f) {
        return send_message_back(s_addr, 0xfffffffe, query_id, -1, 0, 64);
    }

    int m = ms~load_uint(2);
    ms.end_parse();

    cell old_round = pack_old_round(lucky_nums, p1, p2, p3, d);

    save_data(round, old_round, comsa, seqno, owner);

    int amount = 0;
    if (m == 1) {
        amount = p1;
    }
    if (m == 2) {
        amount = p2;
    }
    if (m == 3) {
        amount = p3;
    }
    send_message_back(s_addr, 0x80000003, query_id, -1, amount, 64);
}

;; runs lottery round
;; round, old_round, comsa
(cell, cell, int) conduct_round(cell round) {
    var (prize_fund, participants) = unpack_round(round);

    randomize_lt();

    cell lucky_nums = new_dict();
    lucky_nums~udict_add_builder?(8, 0, begin_cell());
    lucky_nums~udict_add_builder?(8, 1, begin_cell());
    lucky_nums~udict_add_builder?(8, 2, begin_cell());
    ;;int i = 0;
    ;;while (i < 13) {
    ;;    int f = lucky_nums~udict_add_builder?(8, rand(100), begin_cell());
    ;;    if (f) {
    ;;        i += 1;
    ;;   }
    ;;}

    ;; number of winners with 1, 2 and 3 mathced nums
    int c1 = 0;
    int c2 = 0;
    int c3 = 0;
    
    ;; dict with winners with addr as key and number of mathced nums as value
    cell d = new_dict();

    int i = -1;
    do {
        (i, slice nums, int f) = participants.udict_get_next?(256, i);
        if (f) {
            nums~touch();
            var (n1, n2, n3) = (nums~load_uint(8), nums~load_uint(8), nums~load_uint(8));
            nums.end_parse();

            int ff = 0;
            (_, int f1) = lucky_nums.udict_get?(8, n1);
            if (f1) {
                ff += 1;
            }
            (_, f1) = lucky_nums.udict_get?(8, n2);
            if (f1) {
                ff += 1;
            }
            (_, f1) = lucky_nums.udict_get?(8, n3);
            if (f1) {
                ff += 1;
            }

            if (ff == 3) {
                c3 += 1;
                d~udict_set_builder(256, i, begin_cell().store_uint(3, 2));
            }

            if (ff == 2) {
                c2 += 1;
                d~udict_set_builder(256, i, begin_cell().store_uint(2, 2));
            }

            if (ff == 1) {
                c1 += 1;
                d~udict_set_builder(256, i, begin_cell().store_uint(1, 2));
            }
        }
    } until (~ f);

    int pf3 = prize_fund * 6 / 10;
    int pf2 = prize_fund * 22 / 100;
    int pf1 = prize_fund * 15 / 100;
    ;; TODO: calc comsa only from current round tickets, excluding prev round fund?
    int comsa = prize_fund * 3 / 100;

    int next_round_fund = prize_fund - comsa;

    ;; prize for each winner with 1, 2 and 3 matched nums
    int p3 = 0;
    int p2 = 0;
    int p1 = 0;
    if (c1 > 0) {
        p1 = pf1 / c1;
        next_round_fund -= pf1;
    }
    if (c2 > 0) {
        p2 = pf2 / c2;
        next_round_fund -= pf2;
    }
    if (c3 > 0) {
        p3 = pf3 / c3;
        next_round_fund -= pf3;
    }

    ;; reset "next current" round
    round = pack_round(next_round_fund, new_dict());

    ;; form result of current round - prev round
    cell old_round = pack_old_round(lucky_nums, p1, p2, p3, d);

    return (round, old_round, comsa);
}

;; from any account
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();

    if ((flags & 1) | in_msg.slice_empty?()) {
        ;; a bounced message, or a simple transfer without comment - accept money
        return ();
    }

    int op = in_msg~load_uint(32);

    if (op == 0) {
        ;; simple transfer with comment - accept money
        ;; TODO: buy ticket with nums from comment (str -> 3 nums)
        return ();
    }

    ;; TODO: query_id: int64

    if (op == 1) {
        ;; buy a ticket
        return buy_ticket(s_addr, msg_value, in_msg, 0);
    }
    
    if (op == 2) {
        ;; increase prize fund
        in_msg.end_parse();
        return sponsor_prize_fund(msg_value);
    }

    if (op == 3) {
        ;; withdraw prize
        in_msg.end_parse();
        return withdraw_prize(s_addr, 0);
    }

    ifnot (op & (1 << 31)) {
        ;; unknown query - return money
        return send_message_back(s_addr, 0xffffffff, 0, op, 0, 64);
    }

    ;; unknown answer, ignore - accept money
    return ();
}

;; from onwer only
;; based on wallet-v2
() recv_external(slice in_msg) impure {
    slice signature = in_msg~load_bits(512);
    slice cs = in_msg;
    var (msg_seqno, valid_until, op) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
    throw_if(35, valid_until <= now());
    var (round, old_round, comsa, seqno, owner) = load_data();
    throw_unless(33, msg_seqno == seqno);
    throw_unless(34, check_signature(slice_hash(in_msg), signature, owner));
    accept_message();
    if (op == 1) {
        ;; transfer. debug only
        cs~touch();
        while (cs.slice_refs()) {
            int mode = cs~load_uint(8);
            send_raw_message(cs~load_ref(), mode);
        }
        cs.end_parse();
    }
    if (op == 2) {
        ;; conduct round
        cs.end_parse();
        (round, old_round, int new_comsa) = conduct_round(round);
        comsa += new_comsa;
    }
    if (op == 3) {
        ;; withdraw commision
        cs~touch();
        slice dest_addr_s = cs~load_bits(8 + 256);
        cs.end_parse();

        ;; send all comsa
        send_message_back(dest_addr_s, 0x80000013, 0, -1, comsa, 2);
        comsa = 0;
    }
    ;; 9 - op for init
    save_data(round, old_round, comsa, seqno + 1, owner);
}

;; Get methods

int seqno() method_id {
    (_, _, _, int seqno, _) = load_data();
    return seqno;
}

;; return prize fund of current round
int prize_fund() method_id {
    cell round = get_data().begin_parse().preload_dict();
    return round.null?() ? 0 : round.begin_parse().preload_grams();
}

;; return winning nums of prev round
cell lucky_nums() method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return begin_cell().end_cell();
    }
    cell lucky_nums = old_round.begin_parse().preload_dict();
    builder res = begin_cell();
    int i = -1;
    do {
        (i, _, int f) = lucky_nums.udict_get_next?(8, i);
        if (f) {
            res~store_uint(i, 8);
        }
    } until (~ f);
    return res.end_cell();
}

;; return prizes (1, 2 and 3 nums matched) and winners of prev round
(int, int, int, cell) winners() method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return (0, 0, 0, new_dict());
    }
    slice ds = old_round.begin_parse().skip_dict();
    var (p1, p2, p3, d) = (ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    return (p1, p2, p3, d);
}

;; returns prize in prev round for addr
int is_winner(int addr) method_id {
    cell old_round = get_data().begin_parse().skip_dict().preload_dict();
    if (old_round.null?()) {
        return 0;
    }
    slice ds = old_round.begin_parse().skip_dict();
    var (p1, p2, p3, d) = (ds~load_grams(), ds~load_grams(), ds~load_grams(), ds~load_dict());
    (slice ms, int f) = d.udict_get?(256, addr);
    if (f) {
        int m = ms.preload_uint(2);
        if (m == 1) {
            return p1;
        }
        if (m == 2) {
            return p2;
        }
        if (m == 3) {
            return p3;
        }
        return 0;
    }
    return 0;
}

;; returns commision. debug only?
int comsa() method_id {
    return get_data().begin_parse().skip_dict().skip_dict().preload_grams();
}
